name: Update Top 5 Blogs (Pretty)

on:
  schedule:
    - cron: "12 2 * * *"   # daily 02:12 UTC
  workflow_dispatch:
  push:
    paths:
      - .github/workflows/update-blogs.yml
      - README.md

permissions:
  contents: write

jobs:
  update-blogs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Update README Latest Blogs (HTML table)
        run: |
          python - <<'PY'
          import re, sys, requests
          from datetime import datetime, timezone, timedelta
          from urllib.parse import quote

          # ====== CONFIG ======
          API_URL = "https://api.projectdevops.in/blogs"
          SITE_BASE = "https://blogs.projectdevops.in"
          # final link: https://blogs.projectdevops.in/b/<id>-<slug>
          LINK_TEMPLATE = "{base}/b/{id}-{slug}"
          TOP_N = 5
          NEW_DAYS = 7  # show ðŸ†• for posts newer than this many days
          README_PATH = "README.md"
          START_MARK = "<!-- BLOG-POST-LIST:START -->"
          END_MARK   = "<!-- BLOG-POST-LIST:END -->"
          TIMEOUT = 15
          # ====================

          def slugify(title: str) -> str:
              import re as _re
              s = (title or "").strip().lower()
              s = _re.sub(r"[^a-z0-9\\s-]", "", s)
              s = _re.sub(r"\\s+", "-", s).strip("-")
              return s or "post"

          def parse_dt(s: str):
              if not s: return None
              try:
                  s = s.replace("Z", "+00:00")
                  dt = datetime.fromisoformat(s)
                  if dt.tzinfo is None:
                      dt = dt.replace(tzinfo=timezone.utc)
                  return dt
              except Exception:
                  return None

          def fetch_posts():
              r = requests.get(API_URL, timeout=TIMEOUT)
              r.raise_for_status()
              data = r.json()
              if isinstance(data, dict) and "results" in data:
                  data = data["results"]
              if not isinstance(data, list):
                  return []
              data = sorted(data, key=lambda x: x.get("created_at") or x.get("updated_at") or "", reverse=True)
              return data[:TOP_N]

          def to_url(item):
              _id = str(item.get("_id") or item.get("id") or "").strip()
              title = item.get("title") or "Untitled"
              slug = slugify(title)
              return LINK_TEMPLATE.format(base=SITE_BASE, id=quote(_id, safe=""), slug=quote(slug, safe="-")) if _id else SITE_BASE

          def build_html_table(items):
              now = datetime.now(timezone.utc)
              rows = []
              for it in items:
                  title = it.get("title") or "Untitled"
                  url = to_url(it)
                  dt = parse_dt(it.get("created_at") or it.get("updated_at"))
                  date_str = dt.strftime("%Y-%m-%d") if dt else ""
                  is_new = (dt is not None) and ((now - dt) <= timedelta(days=NEW_DAYS))
                  new_badge = " <span>ðŸ†•</span>" if is_new else ""
                  rows.append(
                      f"<tr>"
                      f"<td><a href=\"{url}\">{title}</a>{new_badge}</td>"
                      f"<td align=\"right\"><code>{date_str}</code></td>"
                      f"</tr>"
                  )
              if not rows:
                  rows.append("<tr><td colspan='2'><em>No posts found</em></td></tr>")

              table = (
                  "<table>\n"
                  "  <thead>\n"
                  "    <tr>\n"
                  "      <th align='left'>Title</th>\n"
                  "      <th align='right'>Date</th>\n"
                  "    </tr>\n"
                  "  </thead>\n"
                  "  <tbody>\n"
                  + "\n".join(rows) +
                  "\n  </tbody>\n"
                  "</table>"
              )
              return table

          def update_readme(block_html: str):
              with open(README_PATH, "r", encoding="utf-8") as f:
                  content = f.read()

              pattern = re.compile(rf"({re.escape(START_MARK)})(.*)({re.escape(END_MARK)})", re.DOTALL)
              replacement = f"{START_MARK}\n{block_html}\n{END_MARK}"

              if re.search(pattern, content):
                  new_content = re.sub(pattern, replacement, content)
              else:
                  new_content = content + f"\n\n## Latest Blog Posts\n\n{replacement}\n"

              if new_content != content:
                  with open(README_PATH, "w", encoding="utf-8") as f:
                      f.write(new_content)
                  print("README updated.")
              else:
                  print("README already up to date.")

          try:
              posts = fetch_posts()
              html = build_html_table(posts)
              update_readme(html)
          except Exception as e:
              print(f"ERROR: {e}", file=sys.stderr)
              sys.exit(1)
          PY

      - name: Commit & Push (if changed)
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add README.md
            git commit -m "chore: pretty latest blog posts [skip ci]"
            git push
          else
            echo "No changes."
          fi
